# 应用简介

为了方便用户可以随时调用ai，实现一个可以随时通过api调用的轻量级应用，利用快捷键就可以调出窗口，用户可以随时随地地和ai交互y

## 应用功能

### 应用前端

1. 不同调用有不同的窗口弹出：
    1. 在使用快捷键调用的时候，应用只需要一个小的前端界面（主界面），该界面展示用户输入和api输出
    2. 点击隐藏在任务栏的应用图表，可以显示设置界面，可以设置不同的厂家，以及输入其密匙
2. 主界面应该拥有
    1. 用户输入框
        1. 发送按钮
        2. 更换提示词按钮
        3. 支持md格式
    2. AI输出框
        1. 一件复制按钮
        2. 重新输出按钮
        3. 支持md
        4. 流动输出
    3. 提示词改变框（用过界面调用）
        1. 选择预设提示词
        2. 新建自己提示词
    4. 钉子按钮
        1. 点击钉子，保证主界面一直显示在用户电脑上
        2. 用户点击窗口以外的地方，Python后端捕获到窗口失焦事件，调用 hide() 方法隐藏窗口，等待下一次召唤。
3. 设置界面应该有
    1. ai模型名字（支持openai的）
    2. apikey
    3. 管理提示词界面
    4. 自定义组合键

### 应用后端

1.  应用应该保证轻量级，也就是需要自启动一直保持后台，而且不占用太多的资源，可以随时通过快捷键调用，需要一直监听
2. 目前不需要保存对话信息，只需要使用langchain中的历史记录框架即可，也就是一次使用需要嗲用该次使用的历史记录。

## 应用框架

后端：python，pywebview打包

前端：html，js，css

ai框架：langchain

## AI的任务

对于以上的这个应用，并不需要你完整的写出来，而是将以上的应用拆分成一个又一个小的模块，让用户自行写出来，以锻炼用户的写代码能力

**注意：每个模块的描述要尽量可能的详细，每个功能的拆分需要十分细致，达到辅助用户顺利完成该项目**

# 项目完成要求
## 划

---

**第一阶段：核心窗口与后端基础 (Core Window & Backend Foundation)**

这个阶段的目标是“搭架子”，我们要让应用最基本的窗口跑起来，并建立前后端之间的沟通渠道。

- **模块 1: 项目设置与窗口创建 (Backend)**
- **目标:** 创建一个可以运行的、空白的桌面应用窗口。
- **详细步骤:**
1. 创建项目文件夹，例如 SimpleAI。
2. 使用 Conda 创建并激活一个新的 Python 环境。
3. 安装核心库: pip install pywebview。
4. 在项目根目录创建一个 main.py 文件。
5. 在 main.py 中，编写代码导入 webview，并使用 webview.create_window() 来创建一个指向 index.html 的窗口。
6. 创建一个 index.html 文件，里面可以只写一行 "Hello, World!" 来做测试。
7. 运行 python main.py，你应该能看到一个标题为 "SimpleAI" 的窗口弹出，并显示 "Hello, World!"。
- **模块 2: 主界面基础布局 (Frontend)**
- **目标:** 在 index.html 中，使用 HTML 和 CSS 构建出主界面的基本样貌。
- **详细步骤:**
1. **HTML 结构:**
- 创建一个主容器 div。
- 在容器内，创建两个主要部分：一个用于显示 AI 对话的 div (id: chat-output)，一个用于用户输入的 form (id: input-form)。
- 在 input-form 中，放置一个 textarea 用于多行输入，和一个 button 用于发送。
1. **CSS 样式:**
- 创建一个 style.css 文件，并在 index.html 中引入它。
- 为窗口、输出框、输入框和按钮编写基本的样式，使其看起来像一个简洁的聊天窗口。可以设置一个固定的、较小的窗口尺寸。
- **模块 3: 前后端通信桥梁 (Backend & Frontend)**
- **目标:** 实现 JavaScript 和 Python 之间的函数互调。这是整个应用交互的核心。
- **详细步骤:**
1. **Python to JS:** 在 main.py 中，修改 create_window 的代码，通过 window.evaluate_js() 方法，实现从 Python 调用 JavaScript 函数的能力。你可以先尝试调用一个简单的 alert()。
2. **JS to Python:** 在 main.py 中，定义一个 Python 类，并将其作为 js_api 参数传入 create_window。这个类里的所有公共方法，都可以被前端的 window.pywebview.api 对象调用。
3. **练习:** 在前端的 JS 中，获取输入框的文本，并通过 window.pywebview.api.your_function_name() 将其发送给 Python。Python 函数接收到后，再通过 evaluate_js() 将收到的文本显示在前端的 AI 输出框里。完成这一步，你的应用就打通了任督二脉。

---

**第二阶段：AI 对话功能实现 (Implementing AI Conversation)**

现在我们有了应用的骨架，是时候注入灵魂了——集成 AI 对話能力。

- **模块 4: AI 框架集成 (Backend)**
- **目标:** 在后端引入 LangChain，并配置一个可以工作的 AI 模型。
- **详细步骤:**
1. 安装相关库: pip install langchain langchain-openai python-dotenv。
2. 在项目中创建一个 .env 文件，用于存放你的 OPENAI_API_KEY。
3. 在你的 Python 代码中，加载环境变量，并初始化一个 ChatOpenAI 模型。
4. 修改上一阶段的 Python 接收函数，将接收到的用户输入传递给 ChatOpenAI 模型，并获取返回结果。
5. 将 AI 的返回结果发送回前端。
- **模块 5: 完整的对话流程与历史记录 (Backend & Frontend)**
- **目标:** 实现一次完整的“提问-回答”流程，并让 AI 拥有短期记忆。
- **详细步骤:**
1. **LangChain Memory:** 在后端，引入 LangChain 的 ConversationBufferMemory。将其与你的 ChatOpenAI 模型组合成一个 ConversationChain。
2. **会话管理:** 设计一个逻辑，每次窗口被重新召唤时，可以清空或重新实例化这个 memory，以开启一次全新的对话，这符合你“一次性使用”的需求。
3. **前端交互:** 完善你的 JavaScript 代码，当用户点击发送后，应该能清空输入框，并将用户的消息和 AI 的回复格式化后（比如加上“你”和“AI”的标识）显示在 chat-output 区域。

---

**第三阶段：核心体验优化 (Core Experience Optimization)**

基础功能已经完备，现在我们要让它变得更“好用”和“智能”。

- **模块 6: 全局快捷键与窗口失焦隐藏 (Backend)**
- **目标:** 实现通过快捷键随时召唤窗口，并在用户点击别处时自动隐藏。
- **详细步骤:**
1. 安装快捷键监听库: pip install keyboard。
2. 在 main.py 中，编写一个后台线程或使用异步方式来监听全局快捷键。
3. 当快捷键被按下时，调用 pywebview 窗口实例的 show() 方法。
4. 利用 pywebview 的事件监听机制（例如 window.events.focus_lost），当窗口失去焦点时，调用 hide() 方法。
- **模块 7: “钉住”功能 (Frontend & Backend)**
- **目标:** 添加一个“钉子”按钮，可以固定窗口，使其不因失焦而隐藏。
- **详细步骤:**
1. 在 index.html 中添加一个钉子图标按钮。
2. 用 JavaScript 监听它的点击事件，每次点击切换一个状态变量（例如 isPinned）。
3. 将这个状态通过 JS API 同步给 Python 后端。
4. 在后端的“失焦隐藏”逻辑中加入判断：只有在 isPinned 为 False 的情况下，才执行 hide()。
- **模块 8: 流式输出与 Markdown 渲染 (Frontend & Backend)**
- **目标:** 让 AI 的回答像打字机一样逐字显示，并支持 Markdown 格式。
- **详细步骤:**
1. **后端流式:** 修改 LangChain 的调用方式，使其支持流式输出 (streaming=True)。你需要遍历模型返回的“块”(chunks)，并不断将每个小块发送给前端。
2. **前端追加:** 修改前端的 JS 接收函数，使其不再是替换整个内容，而是在 AI 回答的 div 中不断追加新接收到的文本块。
3. **Markdown:** 引入一个轻量级的 JS Markdown 渲染库（如 marked.js）。在每次 AI 回答完整结束后，用这个库将包含 Markdown 语法的文本转换成 HTML，并渲染到界面上。

---

**第四阶段：应用配置与管理 (Application Configuration & Management)**

最后，我们要为应用添加配置能力，让它更具扩展性。

- **模块 9: 设置界面与功能 (Frontend & Backend)**
- **目标:** 创建一个独立的设置窗口，用于配置 API Key 等信息。
- **详细步骤:**
1. 创建 settings.html 和 settings.js。
2. 在设置页面中添加表单，用于输入 OpenAI API Key 和选择模型。
3. 后端需要编写 save_settings(data) 和 load_settings() 函数，将配置信息保存到本地文件（如 config.json）和从中读取。
4. 这两个函数同样通过 pywebview 的 JS API 暴露给设置界面。
- **模块 10: 系统托盘图标 (Backend)**
- **目标:** 创建一个系统托盘图标，方便用户进行设置或退出。
- **详细步骤:**
1. pywebview 本身支持简单的系统托盘菜单。
2. 在 main.py 中，创建一个菜单，包含“设置”（点击后打开设置窗口）和“退出”（点击后销毁窗口并退出程序）两个选项。
- **模块 11: 提示词管理 (Frontend & Backend)**
- **目标:** 让用户可以自定义和选择不同的 Prompt。
- **详细步骤:**
1. 在主界面添加一个“更换提示词”按钮。
2. 点击后可以弹出一个模态框或者跳转到设置界面的特定部分。
3. 在这里，用户可以查看预设的提示词列表，也可以新增、编辑、删除自己的提示词。
4. 这些提示词数据也需要通过后端的 save/load 函数进行持久化存储。
5. 当用户选择一个提示词后，后端在构建 LangChain chain 时，需要将这个提示词整合进去。